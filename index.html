
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>トラックカートスキャナー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Babel for JSX and TypeScript Transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Load React and ReactDOM (UMD versions for browser compatibility) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

    <!-- Load Google GenAI (UMD version for browser compatibility) -->
    <script src="https://aistudiocdn.com/@google/genai@1.16.0/dist/index.js"></script>

  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.16.0"
  }
}
</script>
</head>
  <body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
      // Libraries are loaded from the CDN and available on the window object.
      // We destructure them here for convenience.
      const { useState, useEffect, useRef, useCallback } = React;
      const { createRoot } = ReactDOM;
      // The UMD bundle exposes the GoogleGenAI class on the window object.
      const { GoogleGenAI } = window;

      // Since we are not importing from modules, we define necessary types here.
      interface GenerateContentResponse {
        text: string;
      }
      enum AppState {
        INPUT,
        SCANNING,
        RESULTS,
      }
      interface TruckInfo {
        date: string;
        truckNumber: string;
      }
      interface ScannedRecord {
        date: string;
        truckNumber: string;
        tagId: string;
      }

      // Gemini Service Logic
      let ai = null;
      let lastUsedApiKey = null;

      function getGoogleAI() {
        const API_KEY = localStorage.getItem('gemini_api_key');
        if (!API_KEY) {
          throw new Error("APIキーが設定されていません。最初の画面でAPIキーを入力してください。");
        }
        if (API_KEY !== lastUsedApiKey || !ai) {
          ai = new GoogleGenAI({ apiKey: API_KEY });
          lastUsedApiKey = API_KEY;
        }
        return ai;
      }

      async function extractTextFromImage(base64Image) {
        try {
          const genAI = getGoogleAI();
          const imagePart = {
            inlineData: { mimeType: 'image/png', data: base64Image },
          };
          const textPart = {
            text: 'この荷札の画像には、通常、上下に2つのバーコードがあります。それぞれのバーコードの上にある数字を両方とも抽出してください。上のバーコードの数字を先に、次に下のバーコードの数字を、カンマで区切って回答してください。例: "12345, 67890"。数字のみを返し、他のテキストは含めないでください。',
          };
          
          const response = await genAI.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [imagePart, textPart] },
          });
          
          const text = response.text.trim();
          if (!text) {
              throw new Error("画像から有効なテキストを抽出できませんでした。");
          }
          return text;
        } catch (error) {
          console.error("Gemini APIの呼び出し中にエラーが発生しました:", error);
          if (error instanceof Error) {
              throw error;
          }
          throw new Error("Gemini APIで画像の処理中に不明なエラーが発生しました。");
        }
      }

      // Icon Components
      const TruckIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M10 17h4V5H2v12h3" /><path d="M22 17H14v-5h8v5z" /><path d="M2 17h12" /><circle cx="7" cy="17" r="2" /><circle cx="17" cy="17" r="2" />
        </svg>
      );
      const CalendarIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2" /><line x1="16" y1="2" x2="16" y2="6" /><line x1="8" y1="2" x2="8" y2="6" /><line x1="3" y1="10" x2="21" y2="10" />
        </svg>
      );
      const CameraIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" /><circle cx="12" cy="13" r="4" />
        </svg>
      );
      const ExportIcon = ({ className }) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" y1="15" x2="12" y2="3" />
          </svg>
      );
      const KeyIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4" />
        </svg>
      );
      const HelpIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          <circle cx="12" cy="12" r="10" /><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" /><line x1="12" y1="17" x2="12.01" y2="17" />
        </svg>
      );

      // Spinner Component
      const Spinner = ({ className = 'w-6 h-6' }) => (
        <svg className={`animate-spin ${className} text-white`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      );

      // InputForm Component
      const InputForm = ({ onStartScanning }) => {
        const [date, setDate] = useState(new Date().toISOString().split('T')[0]);
        const [truckNumber, setTruckNumber] = useState('');
        const [apiKey, setApiKey] = useState('');
        const [showTooltip, setShowTooltip] = useState(false);

        useEffect(() => {
          const savedApiKey = localStorage.getItem('gemini_api_key');
          if (savedApiKey) {
            setApiKey(savedApiKey);
          }
        }, []);

        const handleApiKeyChange = (e) => {
          const newApiKey = e.target.value;
          setApiKey(newApiKey);
          localStorage.setItem('gemini_api_key', newApiKey);
        };

        const handleSubmit = (e) => {
          e.preventDefault();
          if (date && truckNumber && apiKey) {
            onStartScanning({ date, truckNumber });
          }
        };

        return (
          <div className="w-full max-w-md p-8 space-y-8 bg-white rounded-xl shadow-lg">
            <div className="text-center">
              <TruckIcon className="w-16 h-16 mx-auto text-indigo-500" />
              <h1 className="mt-4 text-3xl font-bold text-gray-900">トラックカートスキャナー</h1>
              <p className="mt-2 text-sm text-gray-600">情報を入力してスキャンを開始してください。</p>
            </div>
            <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
              <div className="rounded-md shadow-sm -space-y-px">
                <div>
                  <label htmlFor="api-key" className="sr-only">Gemini API Key</label>
                  <div className="relative">
                    <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <KeyIcon className="h-5 w-5 text-gray-400" />
                    </div>
                    <input id="api-key" name="api-key" type="password" required className="appearance-none rounded-t-md relative block w-full px-3 py-3 pl-10 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm" placeholder="Gemini APIキー" value={apiKey} onChange={handleApiKeyChange} />
                    <div className="absolute inset-y-0 right-0 pr-3 flex items-center">
                      <div className="relative" onMouseEnter={() => setShowTooltip(true)} onMouseLeave={() => setShowTooltip(false)} onClick={() => setShowTooltip(!showTooltip)}>
                        <HelpIcon className="h-5 w-5 text-gray-400 cursor-pointer" />
                        {showTooltip && (
                          <div className="absolute bottom-full mb-2 -right-4 w-64 p-2 bg-gray-800 text-white text-xs rounded-md shadow-lg z-20">
                            APIキーは画像解析に必要です。入力されたキーは、お使いのブラウザに安全に保存され、外部に送信されることはありません。
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
                <div>
                  <label htmlFor="date" className="sr-only">日付</label>
                  <div className="relative">
                    <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <CalendarIcon className="h-5 w-5 text-gray-400" />
                    </div>
                    <input id="date" name="date" type="date" required className="appearance-none relative block w-full px-3 py-3 pl-10 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm" value={date} onChange={(e) => setDate(e.target.value)} />
                  </div>
                </div>
                <div>
                  <label htmlFor="truck-number" className="sr-only">トラック番号</label>
                  <div className="relative">
                    <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <TruckIcon className="h-5 w-5 text-gray-400" />
                    </div>
                    <input id="truck-number" name="truck-number" type="text" required className="appearance-none rounded-b-md relative block w-full px-3 py-3 pl-10 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm" placeholder="トラック番号" value={truckNumber} onChange={(e) => setTruckNumber(e.target.value)} />
                  </div>
                </div>
              </div>
              <div>
                <button type="submit" disabled={!date || !truckNumber || !apiKey} className="group relative w-full flex justify-center py-3 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-indigo-300 disabled:cursor-not-allowed">
                  スキャン開始
                </button>
              </div>
            </form>
          </div>
        );
      };
      
      // CameraScanner Component
      const CameraScanner = ({ onScan, onFinish, scannedCount }) => {
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);
        const [lastScan, setLastScan] = useState(null);
        const videoRef = useRef(null);
        const canvasRef = useRef(null);
        const streamRef = useRef(null);

        const startCamera = useCallback(async () => {
          if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
          }
          if (!navigator.mediaDevices?.getUserMedia) {
            setError("このブラウザはカメラ機能をサポートしていません。");
            return;
          }
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            streamRef.current = stream;
            if (videoRef.current) {
              videoRef.current.srcObject = stream;
            }
          } catch (err) {
            console.warn("Failed to get environment camera, trying any camera:", err);
            try {
              const stream = await navigator.mediaDevices.getUserMedia({ video: true });
              streamRef.current = stream;
              if (videoRef.current) {
                videoRef.current.srcObject = stream;
              }
            } catch (fallbackErr) {
              console.error("Error accessing camera:", fallbackErr);
              setError("カメラにアクセスできませんでした。ブラウザの権限設定を確認してください。");
            }
          }
        }, []);

        useEffect(() => {
          startCamera();
          return () => {
            if (streamRef.current) {
              streamRef.current.getTracks().forEach(track => track.stop());
            }
          };
        }, [startCamera]);

        const handleCapture = async () => {
          if (!videoRef.current || !canvasRef.current) return;
          setIsLoading(true);
          setError(null);
          setLastScan(null);
          try {
              const video = videoRef.current;
              const canvas = canvasRef.current;
              if (video.videoWidth === 0 || video.videoHeight === 0) {
                  throw new Error("カメラが初期化中です。もう一度お試しください。");
              }
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              const context = canvas.getContext('2d');
              if (!context) {
                  throw new Error("キャンバスコンテキストを取得できませんでした。");
              }
              context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
              const dataUrl = canvas.toDataURL('image/png');
              const base64Image = dataUrl.split(',')[1];
              if (!base64Image) {
                  throw new Error("画像データの生成に失敗しました。");
              }
              const tagIdText = await extractTextFromImage(base64Image);
              const tagIds = tagIdText.split(',').map(id => id.trim()).filter(Boolean);
              if (tagIds.length > 0) {
                  onScan(tagIds);
                  setLastScan(tagIds.join(', '));
              } else {
                  throw new Error("荷札から有効な番号を抽出できませんでした。");
              }
          } catch (e) {
              const errorMessage = e instanceof Error ? e.message : 'スキャンに失敗しました。もう一度お試しください。';
              console.error("Capture failed:", e);
              setError(errorMessage);
          } finally {
              setIsLoading(false);
          }
        };
        
        return (
          <div className="w-full max-w-lg mx-auto flex flex-col items-center">
              <div className="relative w-full aspect-[4/3] bg-black rounded-lg overflow-hidden shadow-lg mb-4">
                  <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover" />
                   {isLoading && (
                      <div className="absolute inset-0 bg-black bg-opacity-50 flex flex-col justify-center items-center">
                          <Spinner className="w-12 h-12" />
                          <p className="text-white mt-2">スキャン中...</p>
                      </div>
                  )}
              </div>
              <canvas ref={canvasRef} className="hidden" />
              <div className="text-center mb-4 p-4 bg-white rounded-lg shadow-md w-full">
                  <p className="text-lg font-semibold text-gray-800">スキャンされたカート: <span className="text-indigo-600">{scannedCount}</span></p>
                  {lastScan && <p className="text-sm text-gray-600 mt-1">最後のスキャン: <span className="font-mono bg-gray-200 px-1 rounded">{lastScan}</span></p>}
                  {error && <p className="text-sm text-red-500 mt-2">{error}</p>}
              </div>
              <div className="flex items-center justify-center gap-4 w-full">
                  <button onClick={handleCapture} disabled={isLoading} className="w-20 h-20 bg-white rounded-full flex items-center justify-center shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 transition-transform duration-200 ease-in-out hover:scale-105" aria-label="Scan tag">
                      {isLoading ? <Spinner className="w-8 h-8 text-indigo-600" /> : <CameraIcon className="w-10 h-10 text-indigo-600" />}
                  </button>
                  <button onClick={onFinish} className="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors">
                      完了
                  </button>
              </div>
          </div>
        );
      };

      // ResultsTable Component
      const ResultsTable = ({ records, onScanNew }) => {
        const exportToCSV = () => {
          if (records.length === 0) return;
          const headers = "日付,トラック番号,荷札番号\n";
          const csvContent = records.map(r => `${r.date},${r.truckNumber},"${r.tagId}"`).join("\n");
          const blob = new Blob(["\uFEFF" + headers + csvContent], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement("a");
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          const { date, truckNumber } = records[0];
          link.setAttribute("download", `scans_${truckNumber}_${date}.csv`);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        };

        return (
          <div className="w-full max-w-4xl mx-auto p-6 bg-white rounded-xl shadow-lg">
            <div className="flex justify-between items-center mb-4">
              <h1 className="text-2xl font-bold text-gray-800">スキャン結果</h1>
              <div className="flex gap-2">
                  <button onClick={exportToCSV} disabled={records.length === 0} className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400">
                      <ExportIcon className="w-5 h-5" />
                      CSVでエクスポート
                  </button>
                  <button onClick={onScanNew} className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">
                      別のトラックをスキャン
                  </button>
              </div>
            </div>
            
            {records.length > 0 && (
                <div className='text-sm text-gray-600 mb-4'>
                  <p><span className='font-semibold'>日付:</span> {records[0].date}</p>
                  <p><span className='font-semibold'>トラック番号:</span> {records[0].truckNumber}</p>
                  <p><span className='font-semibold'>スキャン総数:</span> {records.length}</p>
                </div>
            )}

            <div className="overflow-x-auto max-h-96 border rounded-lg">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50 sticky top-0">
                  <tr>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      荷札番号
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {records.length === 0 ? (
                    <tr>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">
                        まだタグはスキャンされていません。
                      </td>
                    </tr>
                  ) : (
                    records.map((record, index) => (
                      <tr key={index}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-mono text-gray-900">
                          {record.tagId}
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>
        );
      };

      // Main App Component
      const App = () => {
        const [appState, setAppState] = useState(AppState.INPUT);
        const [truckInfo, setTruckInfo] = useState(null);
        const [scannedRecords, setScannedRecords] = useState([]);
        const [sessionScans, setSessionScans] = useState([]);

        const handleStartScanning = (info) => {
          setTruckInfo(info);
          setSessionScans([]);
          setAppState(AppState.SCANNING);
        };

        const handleScan = (tagIds) => {
          setSessionScans(prev => [...prev, ...tagIds]);
        };

        const handleFinishScanning = () => {
          if (truckInfo && sessionScans.length > 0) {
            const newRecords = sessionScans.map(tagId => ({
              date: truckInfo.date,
              truckNumber: truckInfo.truckNumber,
              tagId,
            }));
            setScannedRecords(prev => [...prev, ...newRecords]);
          }
          setAppState(AppState.RESULTS);
        };
        
        const handleScanNew = () => {
          setTruckInfo(null);
          setSessionScans([]);
          setAppState(AppState.INPUT);
        };

        const renderContent = () => {
          switch (appState) {
            case AppState.SCANNING:
              return (
                <CameraScanner 
                  onScan={handleScan}
                  onFinish={handleFinishScanning}
                  scannedCount={sessionScans.length}
                />
              );
            case AppState.RESULTS:
              return (
                <ResultsTable
                  records={scannedRecords}
                  onScanNew={handleScanNew}
                />
              );
            case AppState.INPUT:
            default:
              return <InputForm onStartScanning={handleStartScanning} />;
          }
        };

        return (
          <main className="min-h-screen w-full flex items-center justify-center bg-gray-100 p-4">
            {renderContent()}
          </main>
        );
      }

      // Final Render Call
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
